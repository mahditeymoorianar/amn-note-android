 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/app/src/main/java/com/teymoorianar/amnnote/ui/components/FormattedTextField.kt b/app/src/main/java/com/teymoorianar/amnnote/ui/components/FormattedTextField.kt
index c7a39e39d80365410f83a2eb8ae0b08aaf750464..66bea52ae4c0c1853a88f8bbd9e74649a993df4c 100644
--- a/app/src/main/java/com/teymoorianar/amnnote/ui/components/FormattedTextField.kt
+++ b/app/src/main/java/com/teymoorianar/amnnote/ui/components/FormattedTextField.kt
@@ -70,50 +70,52 @@ fun FormattedTextField(
         isError -> MaterialTheme.colorScheme.error
         else -> MaterialTheme.colorScheme.onSurface
     }
 
     val parseResult = remember(value.text) { TextParser.analyze(value.text) }
     val selectionStart = value.selection.min
     val activeBlockIndex = remember(parseResult, selectionStart) {
         findActiveBlock(parseResult, selectionStart)
     }
 
     val visualTransformation = remember(
         parseResult,
         activeBlockIndex,
         typography,
         activeMarkerColor,
     ) {
         MarkerVisualTransformation(
             parsedBlocks = parseResult,
             activeBlockIndex = activeBlockIndex,
             typography = typography,
             activeMarkerColor = activeMarkerColor,
             linkColor = Color(0xFFEA10FF),
         )
     }
 
+private const val BULLET_CHARACTER: Char = '\u2022'
+
     // Trim Android font padding globally at the text level (correct place)
     val mergedTextStyle = textStyle.merge(
         ComposeTextStyle(
             color = baseTextColor,
             platformStyle = PlatformTextStyle(includeFontPadding = false)
         )
     )
 
     BasicTextField(
         value = value,
         onValueChange = onValueChange,
         modifier = modifier,
         enabled = enabled,
         readOnly = readOnly,
         textStyle = mergedTextStyle,
         cursorBrush = cursorBrush,
         interactionSource = interactionSource,
         keyboardOptions = keyboardOptions,
         keyboardActions = keyboardActions,
         singleLine = singleLine,
         minLines = if (singleLine) 1 else minLines,
         maxLines = if (singleLine) 1 else maxLines,
         visualTransformation = visualTransformation,
         decorationBox = { innerTextField ->
             TextFieldDefaults.DecorationBox(
@@ -183,51 +185,51 @@ private fun buildDisplayAnnotatedString(
                 fontWeight = if (block.bold) FontWeight.Bold else null,
                 fontStyle = if (block.italic) FontStyle.Italic else null,
             )
             if (inlineStyle != SpanStyle()) {
                 builder.addStyle(inlineStyle, contentRange.first, contentRange.last + 1)
             }
 
             val paragraphDirection = when (block.direction) {
                 TextDirection.LTR -> ComposeTextDirection.Ltr
                 TextDirection.RTL -> ComposeTextDirection.Rtl
                 TextDirection.NULL -> null
             }
             if (paragraphDirection != null) {
                 builder.addStyle(
                     ParagraphStyle(textDirection = paragraphDirection),
                     contentRange.first,
                     contentRange.last + 1,
                 )
             }
 
             if (block.style == TextStyle.LIST_ITEM) {
                 // Compact list paragraph: indent + smaller lineHeight + trimmed leading
                 builder.addStyle(
                     ParagraphStyle(
                         textIndent = TextIndent(
-                            firstLine = 16.sp,
+                            firstLine = 0.sp,
                             restLine = 16.sp,
                         ),
                         lineHeight = 18.sp,
                         lineHeightStyle = LineHeightStyle(
                             alignment = LineHeightStyle.Alignment.Proportional,
                             trim = LineHeightStyle.Trim.Both
                         )
                     ),
                     contentRange.first,
                     contentRange.last + 1,
                 )
             }
         }
 
         val markerColor =
             if (index == activeBlockIndex) activeMarkerColor else inactiveMarkerColor
 
         parsed.markers.forEach { range ->
             if (range.first <= range.last && range.last < text.length) {
                 builder.addStyle(
                     SpanStyle(color = markerColor),
                     range.first,
                     range.last + 1,
                 )
             }
@@ -256,102 +258,119 @@ private fun spanStyleFor(
 
 class MarkerVisualTransformation(
     private val parsedBlocks: List<TextParser.ParsedBlock>,
     private val activeBlockIndex: Int,
     private val typography: Typography,
     private val activeMarkerColor: Color,
     private val linkColor: Color,
 ) : VisualTransformation {
 
     override fun filter(text: AnnotatedString): TransformedText {
         val src = text.text
         val n = src.length
 
         // 1) Mark characters that belong to markers of NON-active blocks (to be hidden)
         val hide = BooleanArray(n)
         parsedBlocks.forEachIndexed { idx, parsed ->
             if (idx != activeBlockIndex) {
                 parsed.markers.forEach { range ->
                     val start = range.first.coerceAtLeast(0)
                     val end = (range.last + 1).coerceAtMost(n)
                     for (i in start until end) hide[i] = true
                 }
             }
         }
 
+        // Prepare bullet insert positions for non-active list items
+        val bulletInsertions = buildMap {
+            parsedBlocks.forEachIndexed { idx, parsed ->
+                if (parsed.block.style == TextStyle.LIST_ITEM) {
+                    val range = parsed.contentRange
+                    if (range != null) {
+                        put(range.first, idx != activeBlockIndex)
+                    }
+                }
+            }
+        }
+
         // 2) Build transformed text and original -> transformed offset map
         val originalToTransformed = IntArray(n + 1)
         val builder = AnnotatedString.Builder()
         var destIndex = 0
 
         for (i in 0 until n) {
             originalToTransformed[i] = destIndex
             if (!hide[i]) {
+                if (bulletInsertions[i] == true) {
+                    builder.append(BULLET_CHARACTER)
+                    builder.append(' ')
+                    destIndex += 2
+                }
                 builder.append(src[i])
                 destIndex++
             }
         }
         originalToTransformed[n] = destIndex
         val destLen = destIndex
 
         // 3) Add styles (mapped indices)
         parsedBlocks.forEachIndexed { idx, parsed ->
             val block = parsed.block
             val contentRange = parsed.contentRange
 
             if (contentRange != null && contentRange.first <= contentRange.last) {
                 val start = originalToTransformed[contentRange.first]
                 val end = originalToTransformed[contentRange.last + 1]
                 if (start < end) {
                     val baseStyle = spanStyleFor(block.style, typography, linkColor)
                     if (baseStyle != null) builder.addStyle(baseStyle, start, end)
 
                     val inlineStyle = SpanStyle(
                         fontWeight = if (block.bold) FontWeight.Bold else null,
                         fontStyle = if (block.italic) FontStyle.Italic else null,
                     )
                     if (inlineStyle != SpanStyle()) builder.addStyle(inlineStyle, start, end)
 
                     val paragraphDirection = when (block.direction) {
                         TextDirection.LTR -> ComposeTextDirection.Ltr
                         TextDirection.RTL -> ComposeTextDirection.Rtl
                         TextDirection.NULL -> null
                     }
                     if (paragraphDirection != null) {
                         builder.addStyle(
                             ParagraphStyle(textDirection = paragraphDirection),
                             start,
                             end,
                         )
                     }
 
                     if (block.style == TextStyle.LIST_ITEM) {
                         // Match compact list paragraph here too
                         builder.addStyle(
                             ParagraphStyle(
                                 textIndent = TextIndent(
-                                    firstLine = 16.sp,
+                                    firstLine = 0.sp,
                                     restLine = 16.sp,
                                 ),
                                 lineHeight = 18.sp,
                                 lineHeightStyle = LineHeightStyle(
                                     alignment = LineHeightStyle.Alignment.Proportional,
                                     trim = LineHeightStyle.Trim.Both
                                 )
                             ),
                             start,
                             end,
                         )
                     }
                 }
             }
 
             // Markers: only ACTIVE block markers remain in transformed text
             if (idx == activeBlockIndex) {
                 parsed.markers.forEach { range ->
                     val s0 = range.first.coerceAtLeast(0)
                     val e0 = (range.last + 1).coerceAtMost(n)
                     val start = originalToTransformed[s0]
                     val end = originalToTransformed[e0]
                     if (start < end) {
                         builder.addStyle(
                             SpanStyle(color = activeMarkerColor),
 
EOF
)